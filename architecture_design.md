# 多平台消息聚合桌面应用 - 技术架构设计文档

## 一、项目概述

本项目旨在构建一个开源的跨平台桌面应用程序,为用户提供统一的消息聚合平台,能够实时监控多个社交媒体和群组软件(Discord、Telegram、Reddit、微信、QQ、Slack等)中已加入频道的官方公告和活动信息。应用采用模块化架构设计,支持用户通过邮箱或Google账户登录,并在应用内绑定各个平台账户进行授权访问。

### 核心特性

- **多平台支持**: Discord、Telegram、Reddit、微信、QQ、Slack等主流群组软件
- **统一认证**: 通过Google/邮箱登录应用,集中管理所有平台账户绑定
- **实时抓取**: 直接模拟登录各平台账户,绕过API限制,获取完整消息内容
- **智能展示**: 时间线聚合、关键词过滤、重点信息高亮三位一体
- **开源模块化**: 采用插件化架构,方便社区贡献新平台支持
- **跨平台兼容**: 支持Windows、macOS、Linux操作系统

## 二、技术栈选型

### 2.1 桌面应用框架

**选择: Electron**

**理由**:
- **成熟生态**: Electron是目前最成熟的跨平台桌面应用框架,拥有庞大的社区支持(VSCode、Discord、Slack等知名应用均采用)
- **Web技术栈**: 基于Chromium和Node.js,允许使用HTML/CSS/JavaScript构建界面,降低开发门槛
- **完整功能**: 内置自动更新、系统托盘、原生通知、文件系统访问等桌面应用必需功能
- **调试便利**: 可直接使用Chrome DevTools进行调试,开发效率高
- **打包简单**: 支持通过electron-builder一键打包为Windows(.exe)、macOS(.dmg)、Linux(.AppImage)安装包

**备选方案**: Tauri(更轻量,但生态较新,部分平台兼容性待验证)

### 2.2 前端框架

**选择: React + TypeScript**

**理由**:
- **组件化开发**: React的组件化思想非常适合构建复杂的消息聚合界面
- **类型安全**: TypeScript提供静态类型检查,减少运行时错误,提升代码可维护性
- **丰富生态**: 拥有大量成熟的UI组件库和状态管理方案
- **社区活跃**: 遇到问题容易找到解决方案和最佳实践

### 2.3 UI组件库

**选择: Ant Design + Tailwind CSS**

**理由**:
- **Ant Design**: 提供企业级UI组件(表格、表单、通知等),适合构建功能复杂的桌面应用
- **Tailwind CSS**: 实用优先的CSS框架,方便快速定制视觉效果和响应式布局
- **组合使用**: Ant Design负责功能组件,Tailwind CSS负责细节美化,优势互补

### 2.4 后端技术

**选择: Node.js + Express + SQLite**

**理由**:
- **Node.js**: 与Electron无缝集成,可在主进程中直接运行后端逻辑
- **Express**: 轻量级Web框架,用于构建本地API服务(用户认证、数据存储等)
- **SQLite**: 嵌入式数据库,无需独立数据库服务器,适合桌面应用场景,存储用户配置、消息缓存、过滤规则等

### 2.5 消息抓取技术

**选择: Puppeteer + WebSocket + 协议逆向**

**核心策略**:
1. **Puppeteer无头浏览器**: 模拟真实用户登录各平台,绕过反爬虫机制
2. **WebSocket监听**: 对于支持WebSocket的平台(如Discord),直接监听实时消息流
3. **协议逆向**: 分析各平台的私有协议(如Telegram MTProto),实现高效消息拉取
4. **Cookie持久化**: 保存登录态,避免频繁重新登录触发安全验证

**各平台技术方案**:

| 平台 | 抓取方案 | 技术难点 | 解决方案 |
|------|---------|---------|---------|
| Discord | WebSocket监听 + Puppeteer登录 | 需要获取用户Token | 通过Puppeteer登录后提取localStorage中的token |
| Telegram | Telegram Client API (非官方Bot API) | 需要API ID/Hash | 引导用户在Telegram官网申请开发者凭证 |
| Reddit | Puppeteer爬取 + Reddit JSON API | 频率限制 | 使用用户登录态访问,遵守rate limit |
| 微信 | 微信PC协议逆向 (基于已有开源项目) | 协议加密 | 使用成熟的开源库如wechaty |
| QQ | QQ协议逆向 (基于已有开源项目) | 腾讯风控严格 | 使用mirai等成熟框架,降低封号风险 |
| Slack | Slack RTM API (需用户授权) | 需要创建Slack App | 提供详细文档指导用户创建个人App |

### 2.6 用户认证

**选择: Firebase Authentication + Passport.js**

**理由**:
- **Firebase Authentication**: 提供开箱即用的Google登录、邮箱密码登录功能
- **Passport.js**: 灵活的认证中间件,支持多种认证策略
- **安全性**: Firebase处理敏感的认证逻辑,降低安全风险

## 三、系统架构设计

### 3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      桌面应用 (Electron)                      │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │           渲染进程 (Renderer Process)                │   │
│  │                                                       │   │
│  │  ┌─────────────────────────────────────────────┐   │   │
│  │  │         用户界面层 (React + TypeScript)      │   │   │
│  │  │  ┌──────────┐ ┌──────────┐ ┌──────────┐    │   │   │
│  │  │  │登录页面  │ │主界面    │ │设置页面  │    │   │   │
│  │  │  └──────────┘ └──────────┘ └──────────┘    │   │   │
│  │  │                                              │   │   │
│  │  │  ┌──────────────────────────────────────┐  │   │   │
│  │  │  │      消息展示组件                     │  │   │   │
│  │  │  │  • 时间线视图                         │  │   │   │
│  │  │  │  • 分类卡片视图                       │  │   │   │
│  │  │  │  • 仪表盘视图                         │  │   │   │
│  │  │  └──────────────────────────────────────┘  │   │   │
│  │  └─────────────────────────────────────────────┘   │   │
│  │                        ↕ IPC通信                     │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │            主进程 (Main Process)                     │   │
│  │                                                       │   │
│  │  ┌─────────────────────────────────────────────┐   │   │
│  │  │           核心服务层                         │   │   │
│  │  │  ┌──────────────┐  ┌──────────────┐        │   │   │
│  │  │  │认证服务      │  │配置管理服务  │        │   │   │
│  │  │  └──────────────┘  └──────────────┘        │   │   │
│  │  │  ┌──────────────┐  ┌──────────────┐        │   │   │
│  │  │  │消息队列服务  │  │通知服务      │        │   │   │
│  │  │  └──────────────┘  └──────────────┘        │   │   │
│  │  └─────────────────────────────────────────────┘   │   │
│  │                                                       │   │
│  │  ┌─────────────────────────────────────────────┐   │   │
│  │  │       平台抓取引擎 (插件化架构)             │   │   │
│  │  │  ┌──────────┐ ┌──────────┐ ┌──────────┐   │   │   │
│  │  │  │Discord   │ │Telegram  │ │Reddit    │   │   │   │
│  │  │  │Scraper   │ │Scraper   │ │Scraper   │   │   │   │
│  │  │  └──────────┘ └──────────┘ └──────────┘   │   │   │
│  │  │  ┌──────────┐ ┌──────────┐ ┌──────────┐   │   │   │
│  │  │  │WeChat    │ │QQ        │ │Slack     │   │   │   │
│  │  │  │Scraper   │ │Scraper   │ │Scraper   │   │   │   │
│  │  │  └──────────┘ └──────────┘ └──────────┘   │   │   │
│  │  └─────────────────────────────────────────────┘   │   │
│  │                                                       │   │
│  │  ┌─────────────────────────────────────────────┐   │   │
│  │  │         数据持久化层 (SQLite)                │   │   │
│  │  │  • 用户配置表                                │   │   │
│  │  │  • 平台账户绑定表                            │   │   │
│  │  │  • 消息缓存表                                │   │   │
│  │  │  • 关键词规则表                              │   │   │
│  │  └─────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                               │
└─────────────────────────────────────────────────────────────┘
                              ↕
        ┌────────────────────────────────────────┐
        │         外部服务                        │
        │  • Firebase Authentication (用户认证)  │
        │  • 各平台服务器 (消息源)                │
        └────────────────────────────────────────┘
```

### 3.2 模块化设计

#### 3.2.1 插件系统架构

为了实现高度的模块化和可扩展性,采用**插件化架构**设计平台抓取引擎:

```typescript
// 平台抓取器接口定义
interface PlatformScraper {
  // 平台标识
  platformName: string;
  
  // 平台图标
  platformIcon: string;
  
  // 初始化抓取器
  initialize(credentials: any): Promise<void>;
  
  // 登录平台
  login(credentials: any): Promise<boolean>;
  
  // 获取已加入的频道/群组列表
  getChannels(): Promise<Channel[]>;
  
  // 开始监听指定频道的消息
  startListening(channelIds: string[]): void;
  
  // 停止监听
  stopListening(): void;
  
  // 事件: 收到新消息
  onMessage(callback: (message: Message) => void): void;
  
  // 事件: 发生错误
  onError(callback: (error: Error) => void): void;
  
  // 清理资源
  cleanup(): Promise<void>;
}

// 统一消息格式
interface Message {
  id: string;
  platform: string;
  channelId: string;
  channelName: string;
  author: string;
  content: string;
  timestamp: Date;
  attachments?: Attachment[];
  isOfficial?: boolean; // 是否为官方公告
  isPinned?: boolean;   // 是否为置顶消息
}
```

**插件加载机制**:
1. 所有平台抓取器实现统一的`PlatformScraper`接口
2. 主进程在启动时自动扫描`/plugins`目录,动态加载所有插件
3. 用户可通过配置文件启用/禁用特定平台插件
4. 社区开发者可贡献新平台插件,只需实现接口并放入插件目录

#### 3.2.2 消息处理流水线

```
消息抓取 → 消息规范化 → 关键词过滤 → 优先级排序 → 持久化存储 → 前端展示
   ↓            ↓            ↓            ↓            ↓            ↓
各平台插件   统一格式转换   正则/AI匹配   算法评分    SQLite写入   React渲染
```

### 3.3 数据库设计

#### 3.3.1 用户表 (users)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | INTEGER PRIMARY KEY | 用户ID |
| email | TEXT UNIQUE | 邮箱地址 |
| google_id | TEXT | Google账户ID |
| created_at | DATETIME | 创建时间 |
| last_login | DATETIME | 最后登录时间 |

#### 3.3.2 平台账户绑定表 (platform_accounts)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | INTEGER PRIMARY KEY | 绑定ID |
| user_id | INTEGER | 用户ID(外键) |
| platform | TEXT | 平台名称(discord/telegram/reddit等) |
| account_name | TEXT | 平台账户名 |
| credentials | TEXT | 加密后的登录凭证(token/cookie等) |
| is_active | BOOLEAN | 是否启用 |
| created_at | DATETIME | 绑定时间 |

#### 3.3.3 监听频道表 (monitored_channels)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | INTEGER PRIMARY KEY | 记录ID |
| account_id | INTEGER | 平台账户ID(外键) |
| channel_id | TEXT | 频道/群组ID |
| channel_name | TEXT | 频道/群组名称 |
| is_monitoring | BOOLEAN | 是否正在监听 |
| added_at | DATETIME | 添加时间 |

#### 3.3.4 消息缓存表 (messages)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | INTEGER PRIMARY KEY | 消息ID |
| platform | TEXT | 来源平台 |
| channel_id | TEXT | 频道ID |
| channel_name | TEXT | 频道名称 |
| message_id | TEXT | 平台原始消息ID |
| author | TEXT | 发送者 |
| content | TEXT | 消息内容 |
| timestamp | DATETIME | 消息时间 |
| is_official | BOOLEAN | 是否官方消息 |
| is_highlighted | BOOLEAN | 是否被高亮 |
| priority_score | INTEGER | 优先级分数 |
| created_at | DATETIME | 抓取时间 |

#### 3.3.5 关键词规则表 (keyword_rules)

| 字段名 | 类型 | 说明 |
|--------|------|------|
| id | INTEGER PRIMARY KEY | 规则ID |
| user_id | INTEGER | 用户ID(外键) |
| keyword | TEXT | 关键词 |
| rule_type | TEXT | 规则类型(highlight/filter/notify) |
| priority | INTEGER | 优先级 |
| is_regex | BOOLEAN | 是否正则表达式 |
| created_at | DATETIME | 创建时间 |

## 四、核心功能实现方案

### 4.1 用户认证流程

```
1. 用户打开应用 → 显示登录页面
2. 用户选择登录方式:
   a) Google登录 → 调用Firebase Google OAuth → 获取用户信息
   b) 邮箱登录 → 输入邮箱密码 → Firebase验证 → 获取用户信息
3. 登录成功 → 生成本地Session → 跳转主界面
4. 主界面显示"平台账户管理"入口
```

### 4.2 平台账户绑定流程

```
1. 用户点击"添加平台账户"
2. 选择要绑定的平台(Discord/Telegram/Reddit等)
3. 根据平台类型执行不同绑定流程:
   
   Discord:
   - 弹出内嵌浏览器窗口
   - 用户在Discord官网登录
   - Puppeteer提取登录后的Token
   - 保存Token到数据库(加密存储)
   
   Telegram:
   - 引导用户申请API ID/Hash(提供详细教程)
   - 用户输入手机号
   - 发送验证码
   - 验证成功后保存Session
   
   Reddit:
   - 弹出内嵌浏览器窗口
   - 用户登录Reddit
   - 提取Cookie
   - 保存Cookie到数据库
   
   微信/QQ:
   - 显示二维码
   - 用户扫码登录
   - 获取登录态
   - 保存到数据库

4. 绑定成功 → 自动拉取该账户已加入的频道列表
5. 用户勾选要监听的频道 → 开始抓取消息
```

### 4.3 消息抓取与展示流程

```
1. 后台服务启动各平台抓取器
2. 抓取器持续监听已选频道的新消息
3. 收到新消息 → 转换为统一格式 → 存入消息队列
4. 消息处理器从队列取出消息:
   a) 应用关键词过滤规则
   b) 计算优先级分数(基于是否官方、是否包含关键词等)
   c) 判断是否需要高亮显示
   d) 存入SQLite数据库
5. 通过IPC通知渲染进程有新消息
6. 前端React组件更新显示:
   a) 时间线视图: 按时间倒序显示所有消息
   b) 分类卡片视图: 按平台/频道分组显示
   c) 仪表盘视图: 高优先级消息置顶显示
7. 用户可点击消息查看详情、跳转原链接
```

### 4.4 关键词过滤与高亮

**过滤规则类型**:
1. **高亮规则**: 包含特定关键词的消息高亮显示(如"空投"、"白名单")
2. **过滤规则**: 只显示包含特定关键词的消息,隐藏其他消息
3. **通知规则**: 包含特定关键词时发送桌面通知

**实现方式**:
- 支持普通文本匹配和正则表达式匹配
- 支持多关键词组合(AND/OR逻辑)
- 支持按平台/频道设置不同规则
- 提供预设规则模板(如"Web3项目常用关键词")

**智能高亮算法**:
```
优先级分数 = 基础分(10) 
           + 官方账号发送(+50)
           + 置顶消息(+30)
           + 包含高优先级关键词(+20)
           + 包含中优先级关键词(+10)
           + 包含链接(+5)
           + 包含图片/视频(+5)

分数 >= 60: 红色高亮
分数 40-59: 黄色高亮
分数 20-39: 普通显示
分数 < 20: 灰色显示(可选择隐藏)
```

## 五、技术难点与解决方案

### 5.1 反爬虫与账户安全

**问题**: 频繁抓取可能触发平台反爬虫机制,导致账户被封禁

**解决方案**:
1. **模拟真实用户行为**: 使用Puppeteer时设置随机延迟,模拟人类操作节奏
2. **请求频率控制**: 为每个平台设置合理的请求间隔(如Discord限制为1秒/请求)
3. **User-Agent轮换**: 使用真实浏览器的User-Agent,避免被识别为爬虫
4. **Cookie管理**: 妥善保存和更新Cookie,避免频繁重新登录
5. **错误重试机制**: 遇到限流时指数退避重试,而非立即重试
6. **用户提示**: 在应用中明确告知用户风险,建议使用小号进行监控

### 5.2 跨平台兼容性

**问题**: 不同操作系统的系统API和行为差异

**解决方案**:
1. **使用Electron封装**: Electron已处理大部分跨平台差异
2. **路径处理**: 使用Node.js的`path`模块处理文件路径,避免硬编码
3. **原生模块**: 对于需要原生模块的功能(如微信协议),提供不同平台的预编译版本
4. **充分测试**: 在Windows、macOS、Linux三个平台上进行完整测试

### 5.3 数据安全与隐私保护

**问题**: 应用需要存储用户的登录凭证,存在安全风险

**解决方案**:
1. **本地加密存储**: 使用AES-256加密存储所有敏感数据(Token、Cookie、密码)
2. **密钥管理**: 加密密钥存储在操作系统的安全存储中(Windows Credential Manager / macOS Keychain / Linux Secret Service)
3. **最小权限原则**: 只请求必要的权限,不收集用户的其他隐私数据
4. **开源透明**: 代码完全开源,接受社区审计
5. **本地运行**: 所有数据处理在本地完成,不上传到任何服务器(除Firebase认证外)

### 5.4 性能优化

**问题**: 同时监控多个平台和频道可能导致性能问题

**解决方案**:
1. **消息分页加载**: 前端采用虚拟滚动(react-window),只渲染可见区域的消息
2. **数据库索引**: 为常用查询字段(timestamp、platform、channel_id)建立索引
3. **消息缓存策略**: 只保留最近30天的消息,旧消息自动归档或删除
4. **Worker线程**: 将消息抓取和处理放在独立的Worker线程中,避免阻塞主线程
5. **懒加载**: 只在用户打开某个平台/频道时才加载对应的历史消息

## 六、开发计划与里程碑

### Phase 1: 基础框架搭建 (1-2周)
- [x] 技术选型与架构设计
- [ ] Electron项目初始化
- [ ] React + TypeScript前端框架搭建
- [ ] SQLite数据库设计与初始化
- [ ] Firebase认证集成

### Phase 2: 用户认证与账户管理 (1周)
- [ ] 登录页面UI实现
- [ ] Google登录功能
- [ ] 邮箱密码登录功能
- [ ] 平台账户绑定界面
- [ ] 账户管理(添加/删除/编辑)

### Phase 3: 平台抓取引擎开发 (3-4周)
- [ ] 插件系统架构实现
- [ ] Discord抓取器开发
- [ ] Telegram抓取器开发
- [ ] Reddit抓取器开发
- [ ] 微信抓取器开发(可选)
- [ ] QQ抓取器开发(可选)
- [ ] Slack抓取器开发(可选)

### Phase 4: 前端界面与交互 (2周)
- [ ] 主界面布局设计
- [ ] 时间线视图实现
- [ ] 分类卡片视图实现
- [ ] 仪表盘视图实现
- [ ] 频道选择与管理界面
- [ ] 设置页面

### Phase 5: 关键词过滤与高亮 (1周)
- [ ] 关键词规则管理界面
- [ ] 过滤算法实现
- [ ] 高亮算法实现
- [ ] 桌面通知功能

### Phase 6: 打包与部署 (1周)
- [ ] Windows安装包打包
- [ ] macOS安装包打包
- [ ] Linux安装包打包
- [ ] 自动更新功能
- [ ] 应用签名

### Phase 7: 文档与开源发布 (1周)
- [ ] 用户使用手册
- [ ] 开发者文档
- [ ] 插件开发指南
- [ ] GitHub仓库设置
- [ ] 开源许可证选择(建议MIT或GPL-3.0)

**总计预估开发时间: 10-12周**

## 七、开源与社区建设

### 7.1 开源许可证

**建议选择: MIT License**

**理由**:
- 宽松的许可证,允许商业使用和修改
- 有利于吸引更多开发者贡献
- 与大多数开源项目兼容

### 7.2 社区贡献指南

为了方便社区开发者贡献新平台插件,需要提供:
1. **插件开发模板**: 提供一个示例插件,展示如何实现`PlatformScraper`接口
2. **详细文档**: 说明插件的生命周期、事件处理、错误处理等
3. **测试工具**: 提供插件测试工具,方便开发者调试
4. **贡献流程**: 明确的Pull Request流程和代码审查标准

### 7.3 项目推广

1. **GitHub**: 创建项目仓库,编写详细的README
2. **社交媒体**: 在Twitter、Reddit、Discord等平台宣传
3. **产品展示**: 录制演示视频,发布到YouTube
4. **技术博客**: 撰写技术文章,分享开发经验
5. **开源社区**: 提交到Awesome Lists、Product Hunt等平台

## 八、风险评估与应对

### 8.1 法律风险

**风险**: 抓取平台数据可能违反服务条款

**应对**:
1. 在应用中明确声明"仅供个人学习研究使用"
2. 不提供任何商业化服务
3. 尊重各平台的robots.txt和服务条款
4. 不进行大规模数据爬取和转售

### 8.2 技术风险

**风险**: 平台更新协议导致抓取器失效

**应对**:
1. 采用模块化设计,方便快速更新单个平台插件
2. 建立社区维护机制,众包修复问题
3. 提供降级方案,某个平台失效不影响其他平台

### 8.3 用户隐私风险

**风险**: 用户数据泄露

**应对**:
1. 所有敏感数据加密存储
2. 不收集用户的聊天内容和个人信息
3. 提供数据导出和删除功能
4. 定期进行安全审计

## 九、总结

本项目采用成熟的Electron + React技术栈,结合插件化架构设计,能够实现一个功能强大、易于扩展的多平台消息聚合桌面应用。通过模拟登录和协议逆向技术,绕过API限制,为用户提供完整的消息监控能力。同时,开源和模块化的设计理念,有利于社区贡献和长期维护。

**核心优势**:
- ✅ 跨平台兼容(Windows/macOS/Linux)
- ✅ 模块化插件架构,易于扩展新平台
- ✅ 直接账户登录,无API限制
- ✅ 智能过滤和高亮,提升信息获取效率
- ✅ 本地数据存储,保护用户隐私
- ✅ 完全开源,接受社区审计和贡献

**下一步行动**:
1. 创建GitHub仓库
2. 初始化Electron项目
3. 搭建基础开发环境
4. 开始Phase 1开发工作
